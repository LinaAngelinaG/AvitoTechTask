# AvitoTechTask
Данный сервис решает проблему проведения пользовательских экспериментов внутри компании Avito: хранит данные обо всех проводимых и проведенных тестах, а также о пользвотелях, участвоваших в них.

## Содержание
- [Составные элементы](#составные-элементы)
- [Запуск проекта](#запуск-проекта)
- [Возможности сервиса](#возможности-сервиса)
- [Как устроена база данных](#база-данных)
- [Примеры запросов](#запросы)
- [Возникшие проблемы](#проблемы)
- [Swagger](#swagger)

## Составные элементы
- Веб-сервис на языке Golang
- База данных PostgreSQL
- Два docker-контейнера
- Запросы: JSON-формат

## Запуск проекта
Все, что нужно для запуска приложения: скачать файл docker-compose и, находясь в директории с этим файлом, запустить в командной строке:

```sh
docker compose up
```
Есть нюанс в работе базы данных: при долгой работе с ней, то есть при отправке более чем 4-х запросов на сохранение данных, БД виснет и запускает checkpoit. 

Пока что не разобралась с причиной данного феномена, но если запрос не выполняется сразу же, то достаточно прервать работу запущенных конетйнеров и, без удаления данных об образах и контейнерах заново запустить приложение (docker compose up). 

Так естественно, добавленные и измененные в БД данные потеряны не будут. Пока что думаю над возможностью исправления данного бага.

При зависании HTTP-запросов:

```sh
Ctrl + C

> docker compose up
```

## Возможности сервиса

### Базовые возможности
- Создание сегмента на основе полученного имени сегмента (POST)
- Удаление сегмента на основе полученного имени сегмента (DELETE)
- Добавление пользователя в сегменты на основе списока имен сегментов и id пользователя (POST)
- Удаление пользователя из сегментов на основе списока имен сегментов и id пользователя (DELETE)
- Получение списка активных сегментов пользваотеля на основе id пользователя (GET)

### Дополнительные возможности

- Сохранение истории попадания/выбывания пользователя из сегмента с возможностью получения отчета по пользователю за определенный период в качестве ссылки на скачивание CSV-файла на основе id пользователя и периода, заданного годом и месяцем (GET)
- Возможность задавать TTL (время автоматического удаления пользователя из сегмента) на основе кол-ва дней его жизни в сегменте (POST)
- Возможность документирования через Swagger: не до конца реализована.

## Как устроена база данных

База данных состоит из двух сущностей: user_in_segment и segment. На рисунке ниже приведена диаграмма для сущностей. 



user_in_segment нужен, чтобы хранить пользователя в сегменте, а также дату его добавления в сегмент и удаления из сегмента. Это помогает решать сразу несколько проблем: 
- вытаскивать из БД для пользователя только активные сегменты: те, у которых дата удаления из  сегмента до текущей, либо у которых она вовсе отсутствует (по дефолту имеет значение null)
- задавать TTL: при добавления пользователя в сегменты с помощью POST-запроса, указывается значение поля "period" = кол-ву дней, которое пользователь будет существовать в сегменте, атким образом, когда время его "жизни" истечет, то есть текущая дата будет больше даты удаления, записанной на этапе вставки в БД, этот сегмент не будет выбран как активный
- при удалении пользователя из сегмента меняется лишь его дата удаления - если она null или ее значение больше текущего времени
- прежде чем добавлять пользователя в сегмент, нужно добавить сегмент с его иемнем в таблицу segment, иначе добавление пользователя не будет успешным и не имеет смысла

segment необходим для хранения имен сегментов, сопоставляемых id сегмента(который также используется в составном ключе для user_in_segment), а также для хранения информации о том, активен ли сегмент:
- при удалении сегмента из БД, он не удаляется физически, его поле "active" меняется с дефолтного "true" на "false", а также изменяется user_in_segment: все пользователи из удаленного сегмента должны получить новую дату удаления, если она текущая меньше сущетсвующей, либо если она отсутствует (равна null). Это нужно, чтобы не потерять данные об удалении пользователя из сегмента, которое произошло раньше удаления самого сегмента.

## Примеры запросов

В данном разделе разберем цепочку запорсосв, демонстрирующую логику работы сервиса.

```
Добавим сегмент в его таблицу 
``` 
![image](https://github.com/LinaAngelinaG/AvitoTechTask/assets/61655484/582f7cd9-daf2-4c3d-9266-18d20f1396a2)

```
Добавим пользователю 1000 этот сегмент
``` 

```
Получим список активных сегментов пользователя 1000
``` 

```
Получим список активных сегментов несущетсвующего в БД пользователя 10001
``` 

```
Удалим несуществующий сегмент
``` 

```
Получим историю пользователя 1000
``` 


```
Удалим добавленный сегмент пользователя 1000 
``` 
(именно сегмент, а не пользователя из сегмента, то есть поменяется значение "active" для сегмента и не только)


```
Снова получим историю пользователя 1000
``` 

```
Снова получим список активных сегментов пользователя 1000
``` 

```
Проделаем аналогичные операции, только с бОльшим кол-вом пользователей и сегментов
``` 
Кроме того, посмотрим на историю так, как она выглядит в скачанном CSV-файле, а не в JSON-ответе, полученном из ResponseWriter-а.


## Возникшие проблемы
1. Проблема со Swagger: НЕ СУЩЕСТВУЕТ обертки над swaggo/swager для разработки ручки на основе роутера от julienschmidt/httprouter. Однако все ручки задокументированы и сгенерированы yaml и json файлы для работы swagger-а, демонстрация полученных локально страниц в разделе "Swagger". Планирую исправить проблему подключения к Swagger в ближайшее время.
2. Есть нюанс в работе базы данных: при долгой работе с ней, то есть при отправке более чем 4-х запросов на сохранение данных, БД виснет и запускает checkpoit.
3. Не успела качественно поработать с паролями для БД: сейчас они торчат наружу в конфигурации, необходимо аккуратно спрятать их в перемнных окружения, начала эту кропотливую работу, но еще не завершила.

## Swagger


